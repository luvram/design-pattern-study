# 데코레이터 (Decorator) 패턴
### 개념
    객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터를 사용하면 서브 클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있다.
### 설명
    - 데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터들을 사용한다.
    - 데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영한다.
    - 데코레이터에서는 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로서 행동을 확장한다.
    - 구성요소를 감싸는 데코레이터의 개수에는 제한이 없다.
    - 구성요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없다. 클라이언트에서 구성요소의 구체적인 형식에 의존하게 되는 경우는 예외.
### 단점
    - 자잘한 클래스들이 엄청나게 추가되는 경우가 있다. 그러다 보면 남들이 봤을때 이해하기 힘든 디자인이 만들어질 수 있다.
    - 구성 요소를 초기화하는데 필요한 코드가 훨씬 복잡해진다. (팩토리와 빌더 패턴으로 해결 가능)
### 추가
    - 예제에서는 이해를 돕기 위해 `abstract class`를 사용하여 데코레이터 패턴을 구현했지만 가능하다면 `interface`를 사용하는것이 좋다.
    
# 팩토리 (Factory) 패턴
## 팩토리 메서드
### 개념
    팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다.
    즉, 상속을 통해 패턴을 구현하며 클래스를 `extends`하고 팩토리 메소드를 오버라이드 하여 구현한다.
    클라이언트 코드와 인스턴스를 만들어야 할 구상클래스를 분리시켜야 할 때 사용한다.

### 장점     
    - 객체 생성을 처리하며, 이를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화시킬 수 있다. 이렇게 하면 수퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리시킬 수 있다.
    - 객체 생성 코드를 전부 한 객체 또는 메소드에 집어넣으면 코드에서 중복되는 내용을 제거할 수 있고 나중에 관리할 때도 한 군데에만 신경을 쓰면 된다.

## 추상 팩토리
### 개념
    추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다.
    즉, 객체 구성을 통해 구현한다.
    연관된 클래스들의 제품군(family)를 묶어 생성하기 위해 사용한다.

# 싱글턴 (Singleton) 패턴
### 개념
    인스턴스를 반드시 하나만 만들어야 하는 클래스를 생성하는 방법이다.
### 설명
    - 생성자를 `private`로 설정해두고 정적 메서드를 통해 생성된 인스턴스를 얻도록 구현할 수 있다.
    - 기본 구현(`ClassicSingleton`) 은 thread-safe 하지 않으므로 multi thread 작업시 별도의 처리를 해주어야 한다.
        - 속도가 그다지 중요하지 않다면 `getInstance` 메소드에 `synchronized` 키워드를 추가한다. (`SynchronizedSingleton`. 이 방법은 성능이 100배정도 저하될 수 있다.)
        - 애플리케이션에서 반드시 싱글톤의 인스턴스를 사용한다는 보장이 있다면 처음부터 싱글톤의 인스턴스를 만들어둔다 (`EagerInitSingleton`)
        - DCL(Double-Checking Locking) 방식을 사용하여 동기화 부분을 최소화 하여 구현한다 (`DCLSingleton`)
### 단점
    - 클래스 로더가 두 개 이상이라면 같은 클래스를 여러번( 각 클래스 로더마다 한번씩) 로딩할 수 있다. 만약 싱글턴을 그런식으로 로딩하면 그 클래스가 여러번 로딩되었기 때문에 싱글턴의 인스턴스가 여러 개 만들어지는 문제가 발생할 수 있다.
    - 생성자가 `private`으로 되어있어 상속이 어렵다.  