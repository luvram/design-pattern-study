# 데코레이터 (Decorator) 패턴
### 개념
    객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터를 사용하면 서브 클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있다.
### 설명
    - 데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터들을 사용한다.
    - 데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영한다.
    - 데코레이터에서는 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로서 행동을 확장한다.
    - 구성요소를 감싸는 데코레이터의 개수에는 제한이 없다.
    - 구성요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없다. 클라이언트에서 구성요소의 구체적인 형식에 의존하게 되는 경우는 예외.
### 단점
    - 자잘한 클래스들이 엄청나게 추가되는 경우가 있다. 그러다 보면 남들이 봤을때 이해하기 힘든 디자인이 만들어질 수 있다.
    - 구성 요소를 초기화하는데 필요한 코드가 훨씬 복잡해진다. (팩토리와 빌더 패턴으로 해결 가능)
### 추가
    - 예제에서는 이해를 돕기 위해 `abstract class`를 사용하여 데코레이터 패턴을 구현했지만 가능하다면 `interface`를 사용하는것이 좋다.
    
# 팩토리 (Factory) 패턴
## 팩토리 메서드
### 개념
    팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다.
    즉, 상속을 통해 패턴을 구현하며 클래스를 `extends`하고 팩토리 메소드를 오버라이드 하여 구현한다.
    클라이언트 코드와 인스턴스를 만들어야 할 구상클래스를 분리시켜야 할 때 사용한다.

### 장점     
    - 객체 생성을 처리하며, 이를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화시킬 수 있다. 이렇게 하면 수퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리시킬 수 있다.
    - 객체 생성 코드를 전부 한 객체 또는 메소드에 집어넣으면 코드에서 중복되는 내용을 제거할 수 있고 나중에 관리할 때도 한 군데에만 신경을 쓰면 된다.

## 추상 팩토리
### 개념
    추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다.
    즉, 객체 구성을 통해 구현한다.
    연관된 클래스들의 제품군(family)를 묶어 생성하기 위해 사용한다.

# 싱글턴 (Singleton) 패턴
### 개념
    인스턴스를 반드시 하나만 만들어야 하는 클래스를 생성하는 방법이다.
### 설명
    - 생성자를 `private`로 설정해두고 정적 메서드를 통해 생성된 인스턴스를 얻도록 구현할 수 있다.
    - 기본 구현(`ClassicSingleton`) 은 thread-safe 하지 않으므로 multi thread 작업시 별도의 처리를 해주어야 한다.
        - 속도가 그다지 중요하지 않다면 `getInstance` 메소드에 `synchronized` 키워드를 추가한다. (`SynchronizedSingleton`. 이 방법은 성능이 100배정도 저하될 수 있다.)
        - 애플리케이션에서 반드시 싱글톤의 인스턴스를 사용한다는 보장이 있다면 처음부터 싱글톤의 인스턴스를 만들어둔다 (`EagerInitSingleton`)
        - DCL(Double-Checking Locking) 방식을 사용하여 동기화 부분을 최소화 하여 구현한다 (`DCLSingleton`)
### 단점
    - 클래스 로더가 두 개 이상이라면 같은 클래스를 여러번( 각 클래스 로더마다 한번씩) 로딩할 수 있다. 만약 싱글턴을 그런식으로 로딩하면 그 클래스가 여러번 로딩되었기 때문에 싱글턴의 인스턴스가 여러 개 만들어지는 문제가 발생할 수 있다.
    - 생성자가 `private`으로 되어있어 상속이 어렵다.
    
# 커맨드 (Command) 패턴
### 개념
    요구사항을 공통된 메서드로 접근할 수 있도록 캡슐화 하는 방법이다. 
### 설명
    - 인보커에서는 요청을 할 때 커맨드 객체의 `execute()`메소드를 호출하고 커맨드에서는 리시버를 호출하는 방식으로 구현할 수 있다.
    - 요청을 하는 객체와 그 요청을 수행하는 객체를 분리시킬 수 있다.
    - 매크로 커맨드를 구현하여 여러개의 커맨드를 한번에 호출할 수 있도록 구성할수도 있다.
    - 로그 및 트랜잭션 시스템을 구현할때와 같은 상황에 이용할 수 있다. 
### 용어
    - 리시버: 요구사항을 수행하기 위해 어떤 일을 처리해야 하는지 알고 있는 객체
    - 인보커: `execute()` 메소드를 호출함으로써 커맨드 객체에게 특정 작업을 수행해 달라는 요구를 하게됨
    - 커맨드: 리시버에 특정 작업을 처리하라는 지시를 전달함 
    - 클라이언트: `ConcreteCommand`를 생성하고 리시버를 설정한다.

# 어댑터 (Adapter) 패턴
### 개념
    한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.
    인터페이스를 변경하여 클라이언트에서 필요로 하는 인터페이스로 적응시키기 위한 용도로 사용된다. 
### 설명 
    - 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
    - 클라이언트를 특정 구현이 아닌 인터페이스에 연결 시킨다.
    - 어댑터에는 두 종류가 있다.
        - 객체 어댑터: 객체 구성을 사용하여 구현한다.
        - 클래스 어댑터: 다중상속을 이용하여 구현하는 방식. 하지만 자바에서는 다중상속이 불가능하므로 사용할 수 없다. 
### 용어
    - 타겟(target): 어댑터가 구현할 인터페이스
    - 어댑티(adaptee): 실제 동작될 클래스. 
    
# 퍼사드 (Facade) 패턴
### 개념
    어떤 서브시스템에 대한 간단한 인터페이스를 제공하기 위한 용도로 사용된다.
### 설명
    - 복잡한 시스템을 훨씬 쉽게 사용할 수 있다.
    - 한 어댑터에서 타겟 인터페이스를 구현하기 위해 두 개 이상의 어댑티를 감싸야 하는 상황도 생겼을때 사용할 수 있다.
    - 서브시스템 클래스들을 캡슐화하지 않는다. 그냥 서브시스템의 기능을 사용할 수 있는 간단한 인터페이스를 제공한다.
    - 클라이언트 구현과 서브시스템을 분리시킬 수 있다.


# 객체지향 지식
## 최소 지식 원칙
    - 최소 지식 원칙에 따르면, 객체 사이의 상호작용은 될 수 있으면 아주 가까운 "친구" 사이에서만 허용하는것이 좋다.
    - 원칙을 지키기 위해 호출할 수 있는 4가지 메서드
        1. 객체 자체
        2. 메소드에 매개변수로 전달된 객체
        3. 그 메소드에서 생성하거나 인스턴스를 만든 객체
        4. 그 객체에 속하는 구성요소
### 장점
    - 이 원칙을 잘 따르면 객체들 사이의 의존성을 줄일 수 있고, 소프트웨어 관리가 더 용이해질 수도 있다.
### 단점
    - 다른 구성요소에 대한 메소드 호출을 처리하기 위해 "래퍼" 클래스를 더 만들어야 할 수도 있다. 그러다보면 시스템이 더 복잡해지고, 개발 시간도 늘어나고 성능이 떨어질 수도 있다. 